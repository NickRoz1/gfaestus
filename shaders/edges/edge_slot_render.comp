#version 450

#define TILES_WIDE 256
#define TILES_HIGH 256

#define LINE_MAX 128

#include "tile_line_segments.glsl"
#include "geometry.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) readonly buffer TileSlots {
  uint slots[];
} tiles;

layout (set = 0, binding = 1) buffer Image {
  uint pixel[];
} image;


// technically there are 1024 possible line segments, but we'll only
// at most 128, i.e. 4 lines per slot

// shared vec4 lines[1024];
shared vec4 lines[LINE_MAX];

shared uint line_count;

void main() {

  uint pixel_ix = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 4096;

  vec2 pixel = vec2(gl_GlobalInvocationID.xy);
  ivec2 tile = tile_coords(pixel);

  image.pixel[pixel_ix] = 0;

  if (gl_LocalInvocationIndex == 0) {
    line_count = 0;
  }


  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 local_pixel = vec2(gl_LocalInvocationID.xy) + vec2(0.5);


  uint slot_offset = tile.y * TILES_WIDE * 32 + tile.x * 32;

  // prep line segments

  uint slot_id = gl_LocalInvocationIndex / 8;

  uint index_chunk = gl_LocalInvocationIndex % 8;
  uint start = index_chunk * 4;
  uint end = start + 4;


  // TODO heuristic to only render ~4-8 edges/tile max

  if (slot_id < 32) {
    uint slot_ix = (slot_offset + slot_id) % (TILES_WIDE * TILES_HIGH * 32);
    uint slot = tiles.slots[slot_ix];

    for (uint j = start; j < end; j++) {
      if (((1 << j) & slot) != 0) {
        ivec2 q0 = slot_pixel(slot_id);
        ivec2 q1 = slot_pixel(j);

        vec2 p0 = vec2(q0);
        vec2 p1 = vec2(q1);

        uint index = atomicAdd(line_count, 1);

        if (index < LINE_MAX) {
          lines[index] = vec4(p0, p1);
        } else {
          break;
        }
      }
    }
  }

  barrier();

  float min_val;

  bool first = true;
  bool done = false;

  uint count = 0;

  for (uint i = 0; i < line_count; i++) {

    vec4 line = lines[i];

    float val = line_segment_sdf(local_pixel, line.xy, line.zw);

    if (first) {
      first = false;
      min_val = val;
    } else {
      min_val = min(val, min_val);
    }

    if (min_val < 0.0) {
      done = true;
    }

    if (done) {
      break;
    }
  }


  if (min_val < 0.0) {
    // image.pixel[pixel_ix] = clamp(uint(min_val), 0, 255);
    atomicMax(image.pixel[pixel_ix], 255);
    // image.pixel
    // image.pixel[pixel_ix] = 255;
    // image.pixel[pixel_ix] = clamp(uint(min_val * 255.0), 0, 255);
  }

}
