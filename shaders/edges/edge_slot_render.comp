#version 450

#define TILES_WIDE 256
#define TILES_HIGH 256

#include "tile_line_segments.glsl"
#include "geometry.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) readonly buffer TileSlots {
  uint slots[];
} tiles;

layout (set = 0, binding = 1) buffer Image {
  uint pixel[];
} image;

void main() {

  uint pixel_ix = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 4096;

  vec2 pixel = vec2(gl_GlobalInvocationID.xy);
  ivec2 tile = tile_coords(pixel);

  image.pixel[pixel_ix] = 0;

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 local_pixel = vec2(gl_LocalInvocationID.xy) + vec2(0.5);


  uint slot_offset = tile.y * TILES_WIDE * 32 + tile.x * 32;

  // TODO heuristic to only render ~4-8 edges/tile max

  // float val = line_segment_sdf(local_pixel, vec2(0.0), vec2(15.0));
  // image.pixel[pixel_ix] = uint(val * 255.0);

  /*
  ivec2 q0 = slot_pixel(gl_WorkGroupID.x % 32);
  ivec2 q1 = slot_pixel(gl_WorkGroupID.y % 32);

  vec2 p0 = vec2(q0);
  vec2 p1 = vec2(q1);

  float val = line_segment_sdf(local_pixel, p0, p1);
  image.pixel[pixel_ix] = uint((1.0 - val) * 255.0);
  // image.pixel[pixel_ix] = clamp(uint(val * 255.0), 0, 255);

  */



  float min_val;

  bool first = true;

  uint count = 0;

  for (uint i = 0; i < 32; i++) {
  // for (uint i = 0; i < 1; i++) {
    uint slot_ix = (slot_offset + i) % (TILES_WIDE * TILES_HIGH * 32);
    uint slot = tiles.slots[slot_ix];

    bool done = false;

    if (slot == 0) {
      continue;
    }

    for (uint j = 0; j < 32; j++) {
    // for (uint j = 0; j < 4; j++) {
      // if (((slot >> j) & 1) == 1) {
      if (((1 << j) & slot) != 0) {
        ivec2 q0 = slot_pixel(i);
        // ivec2 q0 = slot_pixel(0);
        ivec2 q1 = slot_pixel(j);

        vec2 p0 = vec2(q0);
        vec2 p1 = vec2(q1);

        // vec2 p0 = vec2(q0) + vec2(0.5);
        // vec2 p1 = vec2(q1) + vec2(0.5);

        float val = line_segment_sdf(local_pixel, p0, p1);

        if (first) {
          first = false;
          min_val = val;
        } else {
          min_val = min(val, min_val);
        }

        if (min_val < 0.0) {
          done = true;
          break;
        }

      }
    }
    if (done) {
      break;
    }
  }


  if (min_val < 0.0) {
    // image.pixel[pixel_ix] = clamp(uint(min_val), 0, 255);
    image.pixel[pixel_ix] = 255;
    // image.pixel[pixel_ix] = clamp(uint(min_val * 255.0), 0, 255);
  }

}
