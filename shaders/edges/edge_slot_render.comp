#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96

#include "tile_line_segments.glsl"
#include "geometry.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) readonly buffer TileSlots {
  uint slots[];
} tiles;

layout (set = 0, binding = 1) buffer Image {
  uint pixel[];
} image;

void main() {

  image.pixel[gl_LocalInvocationIndex] = 0;

  barrier();

  vec2 pixel = vec2(gl_GlobalInvocationID.xy);
  ivec2 tile = tile_coords(pixel);

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 local_pixel = vec2(gl_LocalInvocationID.xy);


  uint slot_offset = tile.y * TILES_WIDE + tile.x;

  // TODO heuristic to only render ~4-8 edges/tile max
  for (uint i = 0; i < 32; i++) {
    uint slot = tiles.slots[slot_offset + i];

    for (uint j = 0; j < 32; j++) {
      if (((slot >> j) & 1) == 1) {
        ivec2 q0 = slot_pixel(i);
        ivec2 q1 = slot_pixel(j);

        vec2 p0 = vec2(q0);
        vec2 p1 = vec2(q1);

        float val = line_segment_sdf(local_pixel, p0, p1);

        image.pixel[gl_LocalInvocationIndex] = clamp(uint(val * 255.0), 0, 255);
      }
    }
  }


}
