#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96
// #extension GL_EXT_shader_atomic_float : enable

#define EDGES_PER_WORKGROUP 256

#include "sdf.glsl"
#include "edge_orient.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/*
layout (set = 0, binding = 0) readonly buffer Masks {
  uint tile[];
} masks;

layout (set = 0, binding = 1) readonly buffer EdgeData {
  vec4 edge_points[];
} edges;

layout (set = 0, binding = 2) buffer Image {
  uint pixel[];
  // vec4 pixel[];
} tiles;

layout (push_constant) uniform Dimensions {
  uint width;
  uint height;
} dimensions;
*/

layout (set = 0, binding = 0) readonly buffer Nodes {
  vec2 pos[];
} nodes;

layout (set = 0, binding = 1) readonly buffer Edges {
  uvec2 edge[];
} edges;

layout (set = 0, binding = 2) readonly buffer Masks {
  uint tile[];
} masks;

// layout (rgba8, set = 0, binding = 3) uniform image2D dst;
layout (set = 0, binding = 3) buffer Image {
  uint pixel[];
  // vec4 pixel[];
} tiles;

layout (push_constant) uniform BinPushConstants {
  mat4 view_transform;
  vec2 viewport_dims;
  uint edge_count;
} bin_pc;

// shared vec4 shared_edges[gl_WorkGroupSize.x];
shared vec4 shared_edges[EDGES_PER_WORKGROUP];
shared uint local_edge_count;

uint pixel_index(vec2 tile_rel) {
  uint x = uint(tile_rel.x);
  uint y = uint(tile_rel.y);

  uvec2 offset = uvec2(16 * gl_WorkGroupID.xy);

  uvec2 point = offset + uvec2(x, y);

  return point.x + (point.y * 4096);
}

void main() {

  uint edge_ix_offset = gl_GlobalInvocationID.z * EDGES_PER_WORKGROUP;


  // uint mask_offset = gl_GlobalInvocationID.z * (EDGES_PER_WORKGROUP / 32);

  uint mask_depth = bin_pc.edge_count / 32;

  if (bin_pc.edge_count % 32 != 0) {
    mask_depth += 1;
  }

  uint mask_offset = gl_GlobalInvocationID.z * 32;
  // uint tile_mask_offset = gl_GlobalInvocationID.y + (128 * gl_GlobalInvocationID.x) + mask_offset;
  uint tile_mask_offset = gl_GlobalInvocationID.y + (128 * gl_GlobalInvocationID.x);

  uint column = gl_WorkGroupID.x;
  uint row = gl_WorkGroupID.y;
  // uint column = gl_GlobalInvocationID.x;
  // uint row = gl_GlobalInvocationID.y;


  vec2 pixel_pos = vec2(gl_GlobalInvocationID.xy);

  uint pixel_ix = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 4096;
  // uint pixel_ix = pixel_index(gl_LocalInvocationID.xy);

  /*
  if (gl_GlobalInvocationID.z == 0 &&
      gl_LocalInvocationID.x == 0 &&
      gl_LocalInvocationID.y == 0 &&
      gl_LocalInvocationID.z == 0) {
    tiles.pixel[pixel_ix] = 0;
  }
  */

  if (gl_GlobalInvocationID.x == 0 &&
      gl_GlobalInvocationID.y == 0 &&
      gl_GlobalInvocationID.z == 0) {
    local_edge_count = 0;
  }

  barrier();



  uint edge_ix = gl_LocalInvocationIndex;

  uvec2 this_edge = edges.edge[edge_ix];
  uvec2 oriented_ixs = oriented_edge_ixs(this_edge);

  // vec2 p0 = nodes.pos[this_edge.x];
  // vec2 p1 = nodes.pos[this_edge.y];
  vec2 p0 = nodes.pos[oriented_ixs.x];
  vec2 p1 = nodes.pos[oriented_ixs.y];

  vec4 a = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
  vec4 b = bin_pc.view_transform * vec4(p1, 0.0, 1.0);

  vec2 q0 = a.xy;
  vec2 q1 = b.xy;

  vec4 edge = vec4(q0.x, q0.y, q1.x, q1.y);

  uint local_edge_ix = atomicAdd(local_edge_count, 1);
  shared_edges[gl_LocalInvocationIndex] = edge;

  /*
  if (gl_LocalInvocationID.y < 2) {


    uint local_mask_ix = gl_LocalInvocationID.x + (gl_LocalInvocationID.y * 16);

    uint mask_ix = gl_LocalInvocationID.x;

    uint global_mask_ix = local_mask_ix + tile_mask_offset;
    // uint global_mask_ix = mask_ix + (8 * gl_GlobalInvocationID.z);

    // uint mask = masks.tile[(row + 128 * column) + global_mask_ix];
    uint mask = masks.tile[global_mask_ix];


    // for (uint bit_offset = 0; bit_offset < 2; bit_offset++) {
    for (uint bit_ix = 0; bit_ix < 32; bit_ix++) {

      // uint bit_ix = (gl_LocalInvocationID.y * 2) + bit_offset;

      // if ((mask & (1 << bit_ix)) != 0) {

        uint edge_ix = global_mask_ix + bit_ix;
        // uint edge_ix = edge_ix_offset + (mask_ix * 32) + bit_ix;

        uvec2 this_edge = edges.edge[edge_ix];

        vec2 p0 = nodes.pos[this_edge.x];
        vec2 p1 = nodes.pos[this_edge.y];

        vec4 a = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
        vec4 b = bin_pc.view_transform * vec4(p1, 0.0, 1.0);

        vec2 q0 = a.xy;
        vec2 q1 = b.xy;

        vec4 edge = vec4(q0.x, q0.y, q1.x, q1.y);

        uint local_edge_ix = atomicAdd(local_edge_count, 1);
        shared_edges[gl_LocalInvocationIndex] = edge;
        // shared_edges[local_edge_ix] = edge;
      // }

    }
  }
  */

  barrier();

  // vec2 tile_offset = vec2(16.0 * gl_WorkGroupID.x,
  //                         16.0 * gl_WorkGroupID.y);

  float max_sdf = 0.0;
  float min_sdf = 10000000.0;

  // for (uint edge_ix = 0; edge_ix < local_edge_count; edge_ix++) {
  for (uint edge_ix = 0; edge_ix < 64; edge_ix++) {
    vec4 edge = shared_edges[edge_ix];

    float sdf_at_pixel = line_segment_sdf(pixel_pos, edge.xy, edge.zw);

    max_sdf = max(max_sdf, sdf_at_pixel);
    min_sdf = min(min_sdf, sdf_at_pixel);
  }

  // uint value = clamp(uint(max_sdf), 0, 255);


  // tiles.pixel[pixel_ix] = value;
  // tiles.pixel[pixel_ix] = clamp(local_edge_count % 256, 0, 255);


  uint value = 0;

  if (min_sdf < 2.0) {
    // value = uint((1.0 - (max_sdf / 32.0)) * 255.0);
    float v = clamp(min_sdf / 32.0, 0.0, 1.0);
    v = 1.0 - v;
    value = uint(v * 255.0);
    // value = uint((min_sdf / 32.0) * 255.0);
  }

  tiles.pixel[pixel_ix] = value;


}
