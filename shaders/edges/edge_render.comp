#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96
// #extension GL_EXT_shader_atomic_float : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/*
layout (set = 0, binding = 0) readonly buffer Masks {
  uint tile[];
} masks;

layout (set = 0, binding = 1) readonly buffer EdgeData {
  vec4 edge_points[];
} edges;

layout (set = 0, binding = 2) buffer Image {
  uint pixel[];
  // vec4 pixel[];
} tiles;

layout (push_constant) uniform Dimensions {
  uint width;
  uint height;
} dimensions;
*/

layout (set = 0, binding = 0) readonly buffer Nodes {
  vec2 pos[];
} nodes;

layout (set = 0, binding = 1) readonly buffer Edges {
  uvec2 edge[];
} edges;

layout (set = 0, binding = 2) readonly buffer Masks {
  uint tile[];
} masks;

// layout (rgba8, set = 0, binding = 3) uniform image2D dst;
layout (set = 0, binding = 3) buffer Image {
  uint pixel[];
  // vec4 pixel[];
} tiles;

layout (push_constant) uniform BinPushConstants {
  mat4 view_transform;
  vec2 viewport_dims;
  uint edge_count;
} bin_pc;

// shared vec4 shared_edges[gl_WorkGroupSize.x];


float line_segment_sdf(in vec2 pos, in vec2 p0, in vec2 p1) {
  vec2 pos_0 = pos - p0;
  vec2 pos_1 = p1 - p0;

  float h = clamp(dot(pos_0, pos_1) / dot(pos_1, pos_1), 0.0, 1.0);
  return length(pos_0 - pos_1*h) - 4.0;
}

void main() {

  /*
  uint edge_offset = gl_WorkGroupID.x * gl_WorkGroupSize.x;

  if (gl_LocalInvocationIndex < 15) {
    // uint edge_local_offset = gl_LocalInvocationIndex;
    uint edge_ix = edge_offset + gl_LocalInvocationIndex;

    vec4 edge = edges.edge_points[edge_ix];

    shared_edges[gl_LocalInvocationIndex] = edge;
  }

  barrier();

  uint this_tile = gl_WorkGroupID.x;

  uint column = this_tile % TILES_WIDE;
  uint row = this_tile / TILES_WIDE;

  uvec2 tile_px_offset = uvec2(column * 16,
                               row * 16);

  vec2 tile_offset = vec2(float(column) * 16.0,
                          float(row) * 16.0);

  vec2 local_offset = vec2(gl_LocalInvocationID.x,
                           gl_LocalInvocationID.y) + vec2(0.5);

  uvec2 local_px_offset = uvec2(gl_LocalInvocationID.xy);

  uvec2 pixel_offset = tile_px_offset + local_px_offset;

  uint pixel_start = pixel_offset.x + pixel_offset.y * dimensions.width;

  float value = 0.0;

  for (uint edge_ix = 0; edge_ix < gl_WorkGroupSize.x; edge_ix++) {
    vec4 edge = shared_edges[edge_ix];

    float sdf = line_segment_sdf(tile_offset + local_offset,
                                 edge.xy,
                                 edge.zw);

    value = clamp(sdf + value, 0.0, 1.0);
  }

  uint u_value = uint(value * 255.0);

  atomicMax(tiles.pixel[pixel_start], u_value);
  */

}
