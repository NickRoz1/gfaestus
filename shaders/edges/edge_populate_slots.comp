#version 450

#define TILES_WIDE 256
#define TILES_HIGH 256

#define EDGES_PER_GROUP 256

#include "tile_intersect.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) readonly buffer EdgeBeziers {
  uint edge_count;
  vec2 curve[];
} beziers;

layout (set = 0, binding = 1) buffer TileSlots {
  uint slots[];
} tiles;

shared uint tile_slots[16][16][32];

vec2 test_p0 = vec2(100.0, 220.0);
vec2 test_ctrl = vec2(600.0, 400.0);
vec2 test_p1 = vec2(100.0, 700.0);

void main() {

  uint edge_offset = gl_GlobalInvocationID.z * EDGES_PER_GROUP;
  uint edge_end = min(beziers.edge_count, edge_offset + EDGES_PER_GROUP);

  for (uint i = 0; i < 32; i++) {
    tile_slots[gl_LocalInvocationID.x][gl_LocalInvocationID.y][i] = 0;
  }

  barrier();


  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 tile_center = tile_offset + vec2(7.0);

  // for now we evaluate each group's edges sequentially;
  // later we can use the 16x16 threads we already have to parallelize it

  uint local_x = gl_LocalInvocationID.x;
  uint local_y = gl_LocalInvocationID.y;

  int count = bezier_interval(test_p0, test_ctrl, test_p1);
  float t_del = 1.0 / float(count);



  for (uint i = 0; i < count; i++) {
    vec2 val = bezier_quad(test_p0, test_ctrl, test_p1, t_del * float(i));
    if (val.x >= tile_offset.x && val.x <= tile_offset.x + 16.0
        && val.y >= tile_offset.y && val.y <= tile_offset.y + 16.0) {

      // tile_slots[local_x][local_y][0] |= 1;
      tile_slots[local_x][local_y][0] |= 1 << 8;
      tile_slots[local_x][local_y][0] |= 1 << 12;
      tile_slots[local_x][local_y][0] |= 1 << 16;
      tile_slots[local_x][local_y][0] |= 1 << 20;
      tile_slots[local_x][local_y][0] |= 1 << 24;
      // tile_slots[local_x][local_y][0] |= 1 << 28;
      // tile_slots[local_x][local_y][0] |= 1 << 32;
      // tile_slots[local_x][local_y][0] = 65526;
      // tile_slots[local_x][local_y][0] = 16777216;
      // tile_slots[local_x][local_y][8] = 16777216;
    }
  }


  /*
  vec2 prev_intersect = vec2(0.0);


  for (uint i = 1; i < count; i++) {

    // t_cur = t_del * float(i);
    // cur = bezier_quad(p0, ctrl, p1);

    float t0 = t_del * float(i - 1);
    float t1 = t_del * float(i);

    vec2 intersect = bezier_grid_intersect(tile_center, test_p0, test_ctrl, test_p1, t0, t1);

    if (prev_intersect != vec2(0.0) &&
        intersect != vec2(0.0)) {
      uint ix0 = tile_border_index(prev_intersect);
      uint ix1 = tile_border_index(intersect);

      tile_slots[local_x][local_y][ix0] |= (1 << ix1);
    }

    prev_intersect = intersect;
  }
  */

  /*

  for (uint edge_ix = edge_offset; edge_ix < edge_end; edge_ix++) {
    uint offset = edge_ix * 3;

    vec2 p0   = beziers.curve[offset];
    vec2 ctrl = beziers.curve[offset+1];
    vec2 p1   = beziers.curve[offset+2];

    int count = bezier_interval(p0, ctrl, p1);
    float t_del = 1.0 / float(count);

    vec2 prev_intersect = vec2(0.0);

    for (uint i = 1; i < count; i++) {

      // t_cur = t_del * float(i);
      // cur = bezier_quad(p0, ctrl, p1);

      float t0 = t_del * float(i - 1);
      float t1 = t_del * float(i);

      vec2 intersect = bezier_grid_intersect(tile_center, p0, ctrl, p1, t0, t1);

      if (prev_intersect != vec2(0.0) &&
          intersect != vec2(0.0)) {
        uint ix0 = tile_border_index(prev_intersect);
        uint ix1 = tile_border_index(intersect);

        tile_slots[local_x][local_y][ix0] |= (1 << ix1);
      }

      prev_intersect = intersect;
    }
  }

  */


  barrier();

  uint global_x = gl_GlobalInvocationID.x;
  uint global_y = gl_GlobalInvocationID.y;


  uint tile_slot_offset = (global_y * TILES_WIDE * 32 + global_x * 32);

  if (tile_slot_offset < (TILES_WIDE * TILES_HIGH * 32)) {
    for (uint i = 0; i < 1; i++) {

      atomicOr(tiles.slots[tile_slot_offset + i], tile_slots[local_x][local_y][i]);
    }
  }

}
