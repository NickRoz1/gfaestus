#version 450

#define TILES_WIDE 256
#define TILES_HIGH 256

#define EDGES_PER_GROUP 256

#include "tile_intersect.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) readonly buffer EdgeBeziers {
  uint edge_count;
  vec2 curve[];
} beziers;

layout (set = 0, binding = 1) buffer TileSlots {
  uint slots[];
} tiles;

shared uint tile_slots[16][16][32];

vec2 test_p0 = vec2(100.0, 220.0);
vec2 test_ctrl = vec2(600.0, 400.0);
vec2 test_p1 = vec2(100.0, 700.0);

void main() {

  uint edge_offset = gl_GlobalInvocationID.z * EDGES_PER_GROUP;
  uint edge_end = min(beziers.edge_count, edge_offset + EDGES_PER_GROUP);

  for (uint i = 0; i < 32; i++) {
    tile_slots[gl_LocalInvocationID.x][gl_LocalInvocationID.y][i] = 0;
  }

  barrier();


  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 tile_center = tile_offset + vec2(7.0);

  // for now we evaluate each group's edges sequentially;
  // later we can use the 16x16 threads we already have to parallelize it

  uint local_x = gl_LocalInvocationID.x;
  uint local_y = gl_LocalInvocationID.y;

  int count = bezier_interval(test_p0, test_ctrl, test_p1);
  float t_del = 1.0 / float(count);

  ivec2 this_tile = tile_coords(tile_center);

  vec2 prev_intersect = vec2(0.0);
  vec2 prev_point = bezier_quad(test_p0, test_ctrl, test_p1, 0.0);
  ivec2 prev_tile = tile_coords(prev_point);


  /*
  for (uint i = 1; i < count; i++) {

    // t_cur = t_del * float(i);
    // cur = bezier_quad(p0, ctrl, p1);

    float t0 = t_del * float(i - 1);
    float t1 = t_del * float(i);

    vec2 cur_point = bezier_quad(test_p0, test_ctrl, test_p1, t1);
    ivec2 cur_tile = tile_coords(cur_point);

    ivec2 local_px_0 = ivec2(prev_point) % ivec2(16);
    ivec2 local_px_1 = ivec2(cur_point) % ivec2(16);

    uint ix0 = tile_border_index(local_px_0);
    uint ix1 = tile_border_index(local_px_1);

    if (cur_tile == this_tile) {
      tile_slots[local_x][local_y][ix0] |= (1 << ix1);
    }

  }
  */

  for (uint i = 1; i < count; i++) {
    float t0 = t_del * float(i - 1);
    float t1 = t_del * float(i);

    vec2 cur_point = bezier_quad(test_p0, test_ctrl, test_p1, t1);
    ivec2 cur_tile = tile_coords(cur_point);


    if (cur_point.x < tile_offset.x
        || cur_point.x > tile_offset.x + 16.0
        || cur_point.y < tile_offset.y
        || cur_point.y > tile_offset.y + 16.0) {
      continue;
    }

    if (cur_point.x == prev_point.x) {
      // todo
    } else {
      float x0 = prev_point.x;
      float y0 = prev_point.y;
      float x1 = cur_point.x;
      float y1 = cur_point.y;

      float slope = (y1 - y0) / (x1 - x0);
      float intercept = (x1 * y0 - x0 * y1) / (x1 - x0);

      vec2 line = vec2(slope, intercept);

      ivec2 intersection = tile_line_intersect2(tile_center, line);

      if (intersection.x != -1 && intersection.y != -1) {
        uint ix0 = intersection.x;
        uint ix1 = intersection.y;

        // tile_slots[local_x][local_y][ix0] = 1 << ix1;
        atomicOr(tile_slots[local_x][local_y][ix0], 1 << ix1);
      }

    }

    prev_point = cur_point;
  }

  /*
  float t0 = 0.0;
  float t1 = 0.05;
  float t2 = 0.10;



  ivec2 intersection = tile_line_intersect2(tile_center, vec2(-1.7, 400.0));


  if (intersection != ivec2(-1)) {
    uint ix0 = intersection.x;
    uint ix1 = intersection.y;

    atomicOr(tile_slots[local_x][local_y][ix0], 1 << ix1);
  }
  */

  /*
  for (uint edge_ix = edge_offset; edge_ix < edge_end; edge_ix++) {
    uint offset = edge_ix * 3;

    vec2 p0   = beziers.curve[offset];
    vec2 ctrl = beziers.curve[offset+1];
    vec2 p1   = beziers.curve[offset+2];

    int count = bezier_interval(p0, ctrl, p1);
    float t_del = 1.0 / float(count);

    vec2 prev_intersect = vec2(0.0);

    for (uint i = 1; i < count; i++) {

      // t_cur = t_del * float(i);
      // cur = bezier_quad(p0, ctrl, p1);

      float t0 = t_del * float(i - 1);
      float t1 = t_del * float(i);

      vec2 intersect = bezier_grid_intersect(tile_center, p0, ctrl, p1, t0, t1);

      if (prev_intersect != vec2(0.0) &&
          intersect != vec2(0.0)) {
        uint ix0 = tile_border_index(prev_intersect);
        uint ix1 = tile_border_index(intersect);

        tile_slots[local_x][local_y][ix0] |= (1 << ix1);
      }

      prev_intersect = intersect;
    }
  }

  */


  barrier();

  uint global_x = gl_GlobalInvocationID.x;
  uint global_y = gl_GlobalInvocationID.y;


  uint tile_slot_offset = (global_y * TILES_WIDE * 32 + global_x * 32);

  if (tile_slot_offset < (TILES_WIDE * TILES_HIGH * 32)) {
    for (uint i = 0; i < 32; i++) {

      atomicOr(tiles.slots[tile_slot_offset + i], tile_slots[local_x][local_y][i]);
    }
  }

}
