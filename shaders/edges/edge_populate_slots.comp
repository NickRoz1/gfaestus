#version 450

#define TILES_WIDE 256
#define TILES_HIGH 256

#define EDGES_PER_GROUP 256

#include "tile_intersect.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (set = 0, binding = 0) buffer EdgeBeziers {
  uint edge_count;
  vec2 curve[];
} beziers;

layout (set = 0, binding = 1) buffer TileSlots {
  uint slots[];
} tiles;

shared uint tile_slots[16][16][32];

void main() {

  uint edge_offset = gl_GlobalInvocationID.z * EDGES_PER_GROUP;
  // uint edge_end = min(beziers.edge_count, edge_offset + EDGES_PER_GROUP);
  uint edge_end = beziers.edge_count;


  // if (edge_offset >= beziers.edge_count) {
  //   return;
  // }

  uint global_x = gl_GlobalInvocationID.x;
  uint global_y = gl_GlobalInvocationID.y;

  uint tile_slot_offset = 32 * (global_y * TILES_WIDE + global_x);

  for (uint i = 0; i < 32; i++) {
    tile_slots[gl_LocalInvocationID.x][gl_LocalInvocationID.y][i] = 0;
  }

  if (gl_GlobalInvocationID.z == 0) {
    if (tile_slot_offset < (TILES_WIDE * TILES_HIGH * 32)) {
      for (uint i = 0; i < 32; i++) {
        tiles.slots[tile_slot_offset + i] = 0;
      }
    }
  }

  barrier();

  if (gl_GlobalInvocationID.xyz == uvec3(0)) {
    beziers.edge_count = 0;
  }

  barrier();

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 tile_center = tile_offset + vec2(7.0);

  // for now we evaluate each group's edges sequentially;
  // later we can use the 16x16 threads we already have to parallelize it

  uint local_x = gl_LocalInvocationID.x;
  uint local_y = gl_LocalInvocationID.y;

  ivec2 this_tile = tile_coords(tile_center);

  vec2 prev_intersect = vec2(0.0);

  /*
  for (uint edge_ix; edge_ix < edge_end; edge_ix++) {
    uint offset = edge_ix * 3;

    vec2 p0   = beziers.curve[offset];
    vec2 ctrl = beziers.curve[offset+1];
    vec2 p1   = beziers.curve[offset+2];

    int count = bezier_interval(p0, ctrl, p1);
    float t_del = 1.0 / float(count);

    vec2 prev_point = bezier_quad(p0, ctrl, p1, 0.0);
    ivec2 prev_tile = tile_coords(prev_point);

    for (uint i = 1; i < count; i++) {

      float t0 = t_del * float(i - 1);
      float t1 = t_del * float(i);

      vec2 cur_point = bezier_quad(p0, ctrl, p1, t1);
      ivec2 cur_tile = tile_coords(cur_point);

      if (cur_point.x < tile_offset.x
          || cur_point.x > tile_offset.x + 16.0
          || cur_point.y < tile_offset.y
          || cur_point.y > tile_offset.y + 16.0) {
        continue;
      }

      if (cur_point.x == prev_point.x) {
        // todo
      } else {
        float x0 = prev_point.x;
        float y0 = prev_point.y;
        float x1 = cur_point.x;
        float y1 = cur_point.y;

        float slope = (y1 - y0) / (x1 - x0);
        float intercept = (x1 * y0 - x0 * y1) / (x1 - x0);

        vec2 line = vec2(slope, intercept);

        ivec2 intersection = tile_line_intersect(tile_center, line);

        if (intersection.x != -1 && intersection.y != -1) {
          uint ix0 = intersection.x;
          uint ix1 = intersection.y;

          atomicOr(tiles.slots[tile_slot_offset + ix0],
                   1 << ix1);

          // tile_slots[local_x][local_y][ix0] = 1 << ix1;
          // atomicOr(tile_slots[local_x][local_y][ix0], 2);
          // atomicOr(tile_slots[local_x][local_y][0], 1 << 16);
          // atomicOr(tile_slots[local_x][local_y][ix0], 1 << ix1);

          // atomicOr(tiles.slots[tile_slot_offset], 1 << 16);
                   // tile_slots[local_x][local_y][i]);
        }

      }

      prev_point = cur_point;
    }

    atomicAdd(beziers.edge_count, 1);
  }
  */

  // uint edge_ix = edge_offset;


  uint edge_ix = edge_offset + gl_LocalInvocationIndex;

  if (edge_ix < edge_end) {
    uint offset = edge_ix * 3;

    vec2 p0   = beziers.curve[offset];
    vec2 ctrl = beziers.curve[offset+1];
    vec2 p1   = beziers.curve[offset+2];

    int count = bezier_interval(p0, ctrl, p1);
    float t_del = 1.0 / float(count);

    vec2 prev_point = bezier_quad(p0, ctrl, p1, 0.0);
    ivec2 prev_tile = tile_coords(prev_point);

    for (uint i = 1; i < count; i++) {

      float t0 = t_del * float(i - 1);
      float t1 = t_del * float(i);

      vec2 cur_point = bezier_quad(p0, ctrl, p1, t1);
      ivec2 cur_tile = tile_coords(cur_point);

      if (cur_point.x < tile_offset.x
          || cur_point.x > tile_offset.x + 16.0
          || cur_point.y < tile_offset.y
          || cur_point.y > tile_offset.y + 16.0) {
        continue;
      }

      if (cur_point.x == prev_point.x) {
        // todo
      } else {
        float x0 = prev_point.x;
        float y0 = prev_point.y;
        float x1 = cur_point.x;
        float y1 = cur_point.y;

        float slope = (y1 - y0) / (x1 - x0);
        float intercept = (x1 * y0 - x0 * y1) / (x1 - x0);

        vec2 line = vec2(slope, intercept);

        ivec2 intersection = tile_line_intersect(tile_center, line);

        if (intersection.x != -1 && intersection.y != -1) {
          uint ix0 = intersection.x;
          uint ix1 = intersection.y;

          atomicOr(tiles.slots[tile_slot_offset + ix0],
                   1 << ix1);

          // tile_slots[local_x][local_y][ix0] = 1 << ix1;
          // atomicOr(tile_slots[local_x][local_y][ix0], 2);
          // atomicOr(tile_slots[local_x][local_y][0], 1 << 16);
          // atomicOr(tile_slots[local_x][local_y][ix0], 1 << ix1);

          // atomicOr(tiles.slots[tile_slot_offset], 1 << 16);
                   // tile_slots[local_x][local_y][i]);
        }

      }

      prev_point = cur_point;
    }

    atomicAdd(beziers.edge_count, 1);
  }

  /*
  barrier();

  if (tile_slot_offset < (TILES_WIDE * TILES_HIGH * 32)) {
    for (uint i = 0; i < 32; i++) {

      atomicOr(tiles.slots[tile_slot_offset + i],
               tile_slots[local_x][local_y][i]);
      // tiles.slots[tile_slot_offset + i] = tile_slots[local_x][local_y][i];
    }
  }
  */

}
