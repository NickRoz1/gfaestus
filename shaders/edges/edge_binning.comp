#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96

#define EDGES_PER_WORKGROUP 256

#include "sdf.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// could also process batches of tiles
// layout(local_size_x = 16, local_size_y = 8, local_size_z = 8) in;

layout (set = 0, binding = 0) readonly buffer Nodes {
  vec2 pos[];
} nodes;

layout (set = 0, binding = 1) readonly buffer Edges {
  uvec2 edge[];
} edges;

layout (set = 0, binding = 2) buffer Masks {
  uint tile[];
} masks;

// layout (rgba8, set = 0, binding = 3) uniform image2D dst;

layout (push_constant) uniform BinPushConstants {
  mat4 view_transform;
  vec2 viewport_dims;
  uint edge_count;
} bin_pc;


// [rows][columns][depth]
shared uint tile_masks[32][32][8];

// shared vec2 points_0[gl_WorkGroupSize.x];
// shared vec2 points_1[gl_WorkGroupSize.x];


void main() {

  uint edge_ix_offset = gl_GlobalInvocationID.z * EDGES_PER_WORKGROUP;

  // if (edge_ix_offset >= 256) {
  if (edge_ix_offset >= 1024) {
  // if (edge_ix_offset >= 2048) {
  // if (edge_ix_offset >= 4096) {
  // if (edge_ix_offset >= 8192) {
  // if (edge_ix_offset >= 16384) {
  // if (edge_ix_offset >= bin_pc.edge_count) {
    return;
  }

  uint edge_ix_end = min(edge_ix_offset + EDGES_PER_WORKGROUP,
                         bin_pc.edge_count);

  // divide by 32 since masks are stored in u32s
  uint mask_offset = gl_GlobalInvocationID.z * (EDGES_PER_WORKGROUP / 32);


  uint local_edge_count = edge_ix_end - edge_ix_offset;


  uint column = gl_LocalInvocationID.x;
  uint row = gl_LocalInvocationID.y;

  for (uint z = 0; z < 8; z++) {
    tile_masks[column][row][z] = 0;

    // uint ix = (column * row) + z;
    // uint ix = (column + 128 * row) + z;
    uint ix = (row + 128 * column) + z;

    masks.tile[ix] = 0;
  }

  barrier();

  if (edge_ix_offset >= bin_pc.edge_count) {
    return;
  }

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 center = tile_offset + vec2(7.5);



  for (uint edge_ix = edge_ix_offset; edge_ix < edge_ix_end; edge_ix++) {

    uvec2 this_edge = edges.edge[edge_ix];

    uint mask_ix = edge_ix / 32;
    uint bit_shift = edge_ix % 32;

    uint mask_z = (edge_ix - edge_ix_offset) / 8;

    uint bitmask = 1 << bit_shift;

    vec2 p0 = nodes.pos[this_edge.x];
    vec2 p1 = nodes.pos[this_edge.y];

    vec4 a = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
    vec4 b = bin_pc.view_transform * vec4(p1, 0.0, 1.0);

    vec2 q0 = a.xy;
    vec2 q1 = b.xy;

    float sdf_at_center = line_segment_sdf(center, q0, q1);

    if (sdf_at_center < 8.0) {
    // if (sdf_at_center < 16.0) {
    // if (sdf_at_center < 32.0) {
    // if (sdf_at_center < 64.0) {
      tile_masks[column][row][mask_z] |= bitmask;
      // atomicOr(tile_masks[column][row][mask_z], bitmask);
    }
  }


  // barrier();


  for (uint z = 0; z < 8; z++) {
    // uint ix = (column * row) + z;
    uint ix = (row + 128 * column) + z;

    // atomicOr(masks.tile[ix], 256);
    atomicOr(masks.tile[ix], tile_masks[column][row][z]);
  }

  // barrier();


  /*
  ivec2 tile_pixel_offset = ivec2(gl_GlobalInvocationID.xy) * ivec2(16);

  float value = 0.0;


  for (uint z = 0; z < 8; z++) {
    uint ix = (column * row) + z;

    for (uint i = 0; i < 32; i++) {
      // if ((masks.tile[ix] & (1 << i)) != 0) {
      if ((tile_masks[column][row][z] & (1 << i)) != 0) {
        value += 0.1;
      }
    }
  }
  */

  /*
  for (uint x = 0; x < 16; x++) {
    for (uint y = 0; y < 16; y++) {
      ivec2 pixel = tile_pixel_offset + ivec2(x, y);

      // vec4 color;

      // if ((gl_GlobalInvocationID.x + gl_GlobalInvocationID.y) % 2 == 0) {
      //   color = vec4(0.0, 0.0, 0.0, 0.6);
      // } else {
      //   color = vec4(0.0, 0.0, 0.0, 0.2);
      // }

      // imageStore(dst, pixel, color);

      imageStore(dst, pixel, vec4(0.0, 0.0, 0.0, value * 0.8));

    }
  }
  */

}
