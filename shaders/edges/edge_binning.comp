#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// could also process batches of tiles
// layout(local_size_x = 16, local_size_y = 8, local_size_z = 8) in;

layout (set = 0, binding = 0) readonly buffer Nodes {
  vec2 pos[];
} nodes;

layout (set = 0, binding = 1) readonly buffer Edges {
  uvec2 edge[];
} edges;

layout (set = 0, binding = 2) buffer Masks {
  uint tile[];
} masks;

layout (rgba8, set = 0, binding = 3) uniform image2D dst;

layout (push_constant) uniform BinPushConstants {
  mat4 view_transform;
  vec2 viewport_dims;
  uint edge_count;
} bin_pc;

// shared uint tile_masks[TILES_WIDE][TILES_HIGH];
shared uint tile_masks[32][32];

// shared vec2 points_0[gl_WorkGroupSize.x];
// shared vec2 points_1[gl_WorkGroupSize.x];


float line_segment_sdf(in vec2 pos, in vec2 p0, in vec2 p1) {
  vec2 pos_0 = pos - p0;
  vec2 pos_1 = p1 - p0;

  float h = clamp(dot(pos_0, pos_1) / dot(pos_1, pos_1), 0.0, 1.0);
  return length(pos_0 - pos_1*h) - 4.0;
}

void main() {

  // if (gl_GlobalInvocationID.z * 16 >= bin_pc.edge_count) {
  //   return;
  // }

  // hardcoded edge count lol
  // if (gl_GlobalInvocationID.z > 8) {
  if (gl_GlobalInvocationID.z > 0) {
  // if ((gl_GlobalInvocationID.z / 32) > bin_pc.edge_count) {
    return;
  }

  // uvec2 this_edge = edges.edge[gl_GlobalInvocationID.x];

  // vec2 p0 = nodes.pos[this_edge.x];
  // vec2 p1 = nodes.pos[this_edge.y];

  uint edge_ix_offset = gl_GlobalInvocationID.z * 16;
  // uint edge_ix_offset = 0;

  uint local_edge_count = min(bin_pc.edge_count - edge_ix_offset,
                              // 8);
                              16);

  // uint local_edge_count = 8;

  uint column = gl_LocalInvocationID.x;
  uint row = gl_LocalInvocationID.y;

  tile_masks[column][row] = 0;

  barrier();

  if (edge_ix_offset >= bin_pc.edge_count) {
    return;
  }

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 center = tile_offset + vec2(7.5);

  // vec4 center_4 = bin_pc.view_transform *  vec4(center, 0.0, 1.0);

  // center = center_4.xy;

  for (uint edge_ix = 0; edge_ix < local_edge_count; edge_ix++) {

    uvec2 this_edge = edges.edge[edge_ix_offset + edge_ix];

    uint bitmask = 1 << edge_ix;

    /*
    vec2 p0;
    vec2 p1;

    if (edge_ix == 0) {
      p0 = vec2(170.0, 100.0);
      p1 = vec2(230.0, 200.0);
    } else if (edge_ix == 1) {
      p0 = vec2(270.0, 180.0);
      p1 = vec2(500.0, 500.0);
    } else {
      p0 = vec2(270.0, 180.0);
      p1 = vec2(300.0, 500.0);
    }
    */

    vec2 p0 = nodes.pos[this_edge.x];
    vec2 p1 = nodes.pos[this_edge.y];


    // vec2 q0 = p0;
    // vec2 q1 = p1;

    vec4 a = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
    vec4 b = bin_pc.view_transform * vec4(p1, 0.0, 1.0);


    vec2 q0 = a.xy;
    vec2 q1 = b.xy;

    // vec2 q0 = (0.5 * (vec2(1.0) + a.xy));
    // vec2 q1 = (0.5 * (vec2(1.0) + b.xy));

    // vec2 q0 = (0.5 * (vec2(1.0) + a.xy)) * bin_pc.viewport_dims.xy;
    // vec2 q1 = (0.5 * (vec2(1.0) + b.xy)) * bin_pc.viewport_dims.xy;

    // vec2 q0 = a.xy;
    // vec2 q1 = b.xy;
    // vec2 q0 = abs(p0 / 10000.0) * 800.0;


    // vec2 q1 = abs(p1 / 10000.0) * 800.0;

    // vec2 q0 = vec2(((p0.x - 8917.6) / (34842.9 - 8917.6)) * 2048.0,
    //                ((p0.y + 4481.54) / (2317.5 + 4481.54)) * 1536.0);

    // vec2 q1 = vec2(((p1.x - 8917.6) / (34842.9 - 8917.6)) * 2048.0,
    //                ((p1.y + 4481.54) / (2317.5 + 4481.54)) * 1536.0);

    // vec2 q0 = vec2((p0.x / 26000.0) * 800.0,
    //                (p0.y / 6800.0) * 800.0);

    // vec2 q1 = vec2((p1.x / 26000.0) * 800.0,
    //                (p1.y / 6800.0) * 800.0);

    // vec2 q0 = vec2(clamp(p0.x, 0.0, 1000.0),
    //                clamp(p0.y, 0.0, 1000.0));

    // vec2 q1 = vec2(clamp(p1.x, 0.0, 1000.0),
    //                clamp(p1.y, 0.0, 1000.0));

    /*
    vec4 p0_4 = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
    vec4 p1_4 = bin_pc.view_transform * vec4(p1, 0.0, 1.0);

    p0 = p0_4.xy;
    p1 = p1_4.xy;
    */

    // float sdf_at_center = line_segment_sdf(center, p0, p1);
    float sdf_at_center = line_segment_sdf(center, q0, q1);

    if (sdf_at_center < 8.0) {
    // if (sdf_at_center < 16.0) {
    // if (sdf_at_center < 32.0) {
    // if (sdf_at_center < 64.0) {
      atomicOr(tile_masks[column][row], bitmask);
    }
  }

  barrier();

  atomicOr(masks.tile[column * row], tile_masks[column][row]);

  barrier();

  ivec2 tile_pixel_offset = ivec2(gl_GlobalInvocationID.xy) * ivec2(16);

  float value = 0.0;


  /*
  if (tile_masks[column][row] == 0) {
    value = 0.7;
  } else {
    value = 1.0;
  }
  */


  for (uint i = 0; i < 32; i++) {
    if ((tile_masks[column][row] & (1 << i)) != 0) {
      value += 0.1;
    }
  }

  /*
  if (tile_masks[column][row] > 2) {
    value = 1.0;
  } else if (tile_masks[column][row] > 1) {
    value = 0.7;
  } else {
    value = 0.5;
  }
  */

  /*
  if (gl_GlobalInvocationID.x % 2 == 0) {
    value = 1.0;
  } else {
    value = 0.3;
  }
  */


  // value = float(gl_GlobalInvocationID.x) / 2048.0;

  for (uint x = 0; x < 16; x++) {
    for (uint y = 0; y < 16; y++) {
      ivec2 pixel = tile_pixel_offset + ivec2(x, y);

      /*
      vec4 color;

      if ((gl_GlobalInvocationID.x + gl_GlobalInvocationID.y) % 2 == 0) {
        color = vec4(0.0, 0.0, 0.0, 0.6);
      } else {
        color = vec4(0.0, 0.0, 0.0, 0.2);
      }

      imageStore(dst, pixel, color);
      */

      imageStore(dst, pixel, vec4(0.0, 0.0, 0.0, value * 0.8));

    }
  }

  // for (uint column = 0; column < TILES_WIDE; column++) {
  //   for (uint row = 0; row < TILES_HIGH; row++) {
  //     uint tile_ix = (row * TILES_WIDE) + column;
  //     atomicOr(masks.tile[tile_ix], tile_masks[column][row]);
  //   }
  // }

  /*

  uint bitmask = 1 << gl_LocalInvocationIndex;

  for (uint column = 0; column < TILES_WIDE; column++) {
    for (uint row = 0; row < TILES_HIGH; row++) {

      float left = float(column) * 16.0;
      float right = left + 16.0;

      float up = float(row) * 16.0;
      float down = up + 16.0;

      vec2 center = vec2(7.5 + float(column) * 16,
                         7.5 + float(row) * 16);

      float sdf_at_center = line_segment_sdf(center, p0, p1);

      if (sdf_at_center < 8.0) {
        atomicOr(tile_masks[column][row], bitmask);
      }
    }
  }



  barrier();

  for (uint column = 0; column < TILES_WIDE; column++) {
    for (uint row = 0; row < TILES_HIGH; row++) {
      uint tile_ix = (row * TILES_WIDE) + column;
      atomicOr(masks.tile[tile_ix], tile_masks[column][row]);
    }
  }

  */

  // barrier();

  // for


  /*
  if (gl_GlobalInvocationID.x < (128 * 128)) {

    uint tile_id = gl_GlobalInvocationID.x;

    ivec2 offset = ivec2(16 * (tile_id % 128),
                         16 * (tile_id / 128));


    // ivec2 offset = (ivec2(16, 16) * gl_GlobalInvocationID.x);

    float value = 0.0;

    uint mask = masks.tile[gl_GlobalInvocationID.x];

    for (uint b = 0; b < 32; b++) {
      if (((mask >> b) & 1) != 0) {
        value += 1.0 / 32.0;
      }
    }

    for (uint x = 0; x < 16; x++) {
      for (uint y = 0; y < 16; x++) {
        ivec2 pixel = offset + ivec2(x, y);

        imageStore(dst, pixel, vec4(0.7, 0.7, 0.7, value));
      }
    }
  }
  */


}


float dot2(in vec2 a) {
  return dot(a, a);
}

// from inigo quilez' article on 2D SDFs
float sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )
{
    vec2 a = B - A;
    vec2 b = A - 2.0*B + C;
    vec2 c = a * 2.0;
    vec2 d = A - pos;
    float kk = 1.0/dot(b,b);
    float kx = kk * dot(a,b);
    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
    float kz = kk * dot(d,a);
    float res = 0.0;
    float p = ky - kx*kx;
    float p3 = p*p*p;
    float q = kx*(2.0*kx*kx-3.0*ky) + kz;
    float h = q*q + 4.0*p3;
    if( h >= 0.0)
    {
        h = sqrt(h);
        vec2 x = (vec2(h,-h)-q)/2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
        res = dot2(d + (c + b*t)*t);
    }
    else
    {
        float z = sqrt(-p);
        float v = acos( q/(p*z*2.0) ) / 3.0;
        float m = cos(v);
        float n = sin(v)*1.732050808;
        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
        res = min( dot2(d+(c+b*t.x)*t.x),
                   dot2(d+(c+b*t.y)*t.y) );
        // the third root cannot be the closest
        // res = min(res,dot2(d+(c+b*t.z)*t.z));
    }
    return sqrt( res );
}
