#version 450

#define TILES_WIDE 128
#define TILES_HIGH 96

#define EDGES_PER_WORKGROUP 256

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// could also process batches of tiles
// layout(local_size_x = 16, local_size_y = 8, local_size_z = 8) in;

layout (set = 0, binding = 0) readonly buffer Nodes {
  vec2 pos[];
} nodes;

layout (set = 0, binding = 1) readonly buffer Edges {
  uvec2 edge[];
} edges;

layout (set = 0, binding = 2) buffer Masks {
  uint tile[];
} masks;

layout (rgba8, set = 0, binding = 3) uniform image2D dst;

layout (push_constant) uniform BinPushConstants {
  mat4 view_transform;
  vec2 viewport_dims;
  uint edge_count;
} bin_pc;


// [rows][columns][depth]
shared uint tile_masks[32][32][8];

// shared vec2 points_0[gl_WorkGroupSize.x];
// shared vec2 points_1[gl_WorkGroupSize.x];


float line_segment_sdf(in vec2 pos, in vec2 p0, in vec2 p1) {
  vec2 pos_0 = pos - p0;
  vec2 pos_1 = p1 - p0;

  float h = clamp(dot(pos_0, pos_1) / dot(pos_1, pos_1), 0.0, 1.0);
  return length(pos_0 - pos_1*h) - 4.0;
}

void main() {

  uint edge_ix_offset = gl_GlobalInvocationID.z * EDGES_PER_WORKGROUP;

  // if (edge_ix_offset >= 256) {
  if (edge_ix_offset >= 1024) {
  // if (edge_ix_offset >= 2048) {
  // if (edge_ix_offset >= 4096) {
  // if (edge_ix_offset >= 8192) {
  // if (edge_ix_offset >= 16384) {
  // if (edge_ix_offset >= bin_pc.edge_count) {
    return;
  }

  uint edge_ix_end = min(edge_ix_offset + EDGES_PER_WORKGROUP,
                         bin_pc.edge_count);

  // divide by 32 since masks are stored in u32s
  uint mask_offset = gl_GlobalInvocationID.z * (EDGES_PER_WORKGROUP / 32);


  uint local_edge_count = edge_ix_end - edge_ix_offset;


  uint column = gl_LocalInvocationID.x;
  uint row = gl_LocalInvocationID.y;

  for (uint z = 0; z < 8; z++) {
    tile_masks[column][row][z] = 0;

    uint ix = (column * row) + z;

    masks.tile[ix] = 0;
  }

  barrier();

  if (edge_ix_offset >= bin_pc.edge_count) {
    return;
  }

  vec2 tile_offset = vec2(16.0 * gl_GlobalInvocationID.x,
                          16.0 * gl_GlobalInvocationID.y);

  vec2 center = tile_offset + vec2(7.5);



  for (uint edge_ix = edge_ix_offset; edge_ix < edge_ix_end; edge_ix++) {

    uvec2 this_edge = edges.edge[edge_ix];

    uint mask_ix = edge_ix / 32;
    uint bit_shift = edge_ix % 32;

    uint mask_z = (edge_ix - edge_ix_offset) / 8;

    uint bitmask = 1 << bit_shift;

    vec2 p0 = nodes.pos[this_edge.x];
    vec2 p1 = nodes.pos[this_edge.y];

    vec4 a = bin_pc.view_transform * vec4(p0, 0.0, 1.0);
    vec4 b = bin_pc.view_transform * vec4(p1, 0.0, 1.0);

    vec2 q0 = a.xy;
    vec2 q1 = b.xy;

    float sdf_at_center = line_segment_sdf(center, q0, q1);

    if (sdf_at_center < 8.0) {
    // if (sdf_at_center < 16.0) {
    // if (sdf_at_center < 32.0) {
    // if (sdf_at_center < 64.0) {
      tile_masks[column][row][mask_z] |= bitmask;
      // atomicOr(tile_masks[column][row][mask_z], bitmask);
    }
  }


  // barrier();


  for (uint z = 0; z < 8; z++) {
    uint ix = (column * row) + z;
    atomicOr(masks.tile[ix], tile_masks[column][row][z]);
  }

  // barrier();


  /*
  ivec2 tile_pixel_offset = ivec2(gl_GlobalInvocationID.xy) * ivec2(16);

  float value = 0.0;


  for (uint z = 0; z < 8; z++) {
    uint ix = (column * row) + z;

    for (uint i = 0; i < 32; i++) {
      // if ((masks.tile[ix] & (1 << i)) != 0) {
      if ((tile_masks[column][row][z] & (1 << i)) != 0) {
        value += 0.1;
      }
    }
  }
  */

  /*
  for (uint x = 0; x < 16; x++) {
    for (uint y = 0; y < 16; y++) {
      ivec2 pixel = tile_pixel_offset + ivec2(x, y);

      // vec4 color;

      // if ((gl_GlobalInvocationID.x + gl_GlobalInvocationID.y) % 2 == 0) {
      //   color = vec4(0.0, 0.0, 0.0, 0.6);
      // } else {
      //   color = vec4(0.0, 0.0, 0.0, 0.2);
      // }

      // imageStore(dst, pixel, color);

      imageStore(dst, pixel, vec4(0.0, 0.0, 0.0, value * 0.8));

    }
  }
  */

}


float dot2(in vec2 a) {
  return dot(a, a);
}

// from inigo quilez' article on 2D SDFs
float sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )
{
    vec2 a = B - A;
    vec2 b = A - 2.0*B + C;
    vec2 c = a * 2.0;
    vec2 d = A - pos;
    float kk = 1.0/dot(b,b);
    float kx = kk * dot(a,b);
    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
    float kz = kk * dot(d,a);
    float res = 0.0;
    float p = ky - kx*kx;
    float p3 = p*p*p;
    float q = kx*(2.0*kx*kx-3.0*ky) + kz;
    float h = q*q + 4.0*p3;
    if( h >= 0.0)
    {
        h = sqrt(h);
        vec2 x = (vec2(h,-h)-q)/2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
        res = dot2(d + (c + b*t)*t);
    }
    else
    {
        float z = sqrt(-p);
        float v = acos( q/(p*z*2.0) ) / 3.0;
        float m = cos(v);
        float n = sin(v)*1.732050808;
        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
        res = min( dot2(d+(c+b*t.x)*t.x),
                   dot2(d+(c+b*t.y)*t.y) );
        // the third root cannot be the closest
        // res = min(res,dot2(d+(c+b*t.z)*t.z));
    }
    return sqrt( res );
}
