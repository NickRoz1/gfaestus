* plan/next

[2021-02-11 Thu 17:00]

It looks like drawing tons of fairly small triangles is something GPUs
hate doing, and instancing doesn't help with that

it may be worth thinking about rendering each spine as a single consecutive
rectangle (or at least much fewer rectangles, each containing many nodes),
and letting the fragment shader handle not rendering the space between nodes

[2021-02-11 Thu 16:30]

loading GFAs from file (into packedgraphs) and rendering them, one
spine per path, and it seems to be working pretty well, with a yeast
pangenome (500k nodes, 112 paths, total path length 2.1M) running at
what looks to be around 30-45FPS.

A smaller graph with more paths can be ridiculously slow, as each path
gets its own `draw` command and vertex & uniform buffers, so I'll need
to fix that somehow.

More generally, I need to design a better, a more robust and flexible,
rendering system/loop -- ideally one that can take advantage of
multiple threads. To do that, though, I definitely need to read up on
how Vulkan works.

I also need to move the physics simulation to another thread.

[2021-02-10 Wed 21:30]

GUI crates:

imgui seems to be okay, but maybe a bit clunky to use, and there's only a 3rd-party,
unstable, vulkano renderer

egui looks more flexible, and is 100% rust and backend-agnostic
https://crates.io/crates/egui

another option is conrod and conrod-vulkano
https://crates.io/crates/conrod_vulkano

[2021-02-09 Tue 20:30]

making progress, but there's an annoying thing where motion looks kinda "snappy";
like the length of segments isn't constant, changing by a pixel or two as a segment
moves across pixel borders

antialiasing only helped a little

I think the problem may have to do with the translation and/or projection matrix

replacing some dumb equations that always evaluate to zero with 0.0 may have helped
a little bit

reversing the order of the translation & scaling matrices in the projection matrix
may have helped? but probably not

scaling the x-translation by the ratio of width/height also may have helped

either way, at this point it's really not that bad

it also seems to depend on the update rate -- I definitely need to restructure the
way animation updates are applied, so it doesn't depend on any locks

[2021-02-08 Mon 21:00]

read a GFA, take the paths

construct a linear sequence of rects/nodes to be rendered from each path;
all nodes just 1 or 2 degree to start with


once that's working, break the graph down into linear components, lay
them out in that way, and then reconnect them & apply some kind of
force to lay out the parallel parts


after that i need to handle loops, and probably a whole lot more

* stuff


- [ ] export PNG
  - [ ] start with exporting a screenshot of the current view
  - [ ] then export a larger view of the graph, using a separate framebuffer

- [ ] improve mapping from mouse (screen) to world coordinates

- [X] separate color buffer & individual segment colors
- [ ] text rendering/GUI
- [X] load & render paths -- each with separate color, maybe?

- [ ] proper rendering system that maps a laid out GFA (or subset
  thereof) to vertices & colors ready to be rendered

- [X] MVP matrix transform for scaling & translation
- [X] GFA segments w/ length based on seq length
- [ ] extremely simple linear & greedy layout
- [X] render GFA segments
- [ ] render links as lines between segments


- [ ] more rigorous viewport logic & management
- [X] antialiasing


- [ ] proper layouts

* user actions

** menu
- load GFA
- save layout
- export image/SVG

- filter visible nodes/spines/edges/etc.
  - hide filtered elements
  - highlight filtered elements

- remove nodes/spines/edges/etc. (would require selection first?)

- configure visual parameters
  - set node width & base length (does base length impact physics?)
  - set edge width
  - change node color scheme
  - change spine color scheme
  - change edge color scheme

- configure physics parameters
  - set anim/physics speed
  - set edge min/max length
  - set edge springiness and other parameters

- view and modify spine Fourier coefficients

** any, discrete
- reset view
- reset scale
- pause layout (keyboard)
- reset layout
- select all?
- goto selection?
- menu navigation


** any, continuous
- menu navigation

** mouse only
- mousewheel zoom (centered on cursor)
- click & drag pan
- click & drag pan, but wrt distance from click until released
- draw rectangle & zoom to it
- click to select element
- hover on element
- click & drag elements

** keyboard only
- pan (arrow keys)
- zoom?
- modifiers

*** keyboard modifiers
- pan view with mouse
- faster pan/zoom
- slower pan/zoom
- drag elements with mouse
- select additional elements
